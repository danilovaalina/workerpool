# Worker Pool

## Описание проекта

Проект включает две реализации пула воркеров:
1. **Через каналы (`ChanWorkerPool`)**.
2. **Через `sync.Cond` (`CondWorkerPool`)**.

Каждая реализация предоставляет настройки для оптимизации производительности, такие как установка размера буфера для очереди задач (jobs) или выполнение задач пакетами (batch processing).

---

### 1. **Настройки ChanWorkerPool**
- **Установка размера буфера для канала задач:**
    - Используйте опцию `WithJobLimit(limit int)` для создания буферизованного канала:
      ```go
      wp := workerpool.NewChanWorkerPool(workerpool.WithJobLimit(100)) // Создает канал с буфером на 100 задач
      ```
    - **Зачем это нужно?**
        - Буферизация канала снижает частоту блокировок при добавлении задач, что особенно полезно при работе с большим количеством задач.

- **Увеличение и уменьшение количества воркеров:**
    - Вы можете динамически изменять количество активных воркеров:
      ```go
      wp.IncWorkers(4) // Увеличивает количество воркеров до 4
      wp.DecWorkers(2) // Уменьшает количество воркеров на 2
      ```

- **Закрытие пула:**
    - Метод `CloseAndWait()` останавливает все воркеры и освобождает ресурсы.

---

### 2. **Настройки CondWorkerPool**
- **Выполнение задач пакетами (batch processing):**
    - Используйте опцию `WithBatchSize(size int)` для выполнения задач кусками:
      ```go
      wp := workerpool.NewCondWorkerPool(workerpool.WithBatchSize(5)) // Воркер берет по 5 задач за раз
      ```
    - **Зачем это нужно?**
        - Batch processing минимизирует накладные расходы на управление очередью и синхронизацию, что улучшает производительность, особенно при работе с I/O-bound задачами.

- **Увеличение и уменьшение количества воркеров:**
    - Аналогично `ChanWorkerPool`, вы можете динамически изменять количество воркеров:
      ```go
      wp.IncWorkers(4) // Увеличивает количество воркеров до 4
      wp.DecWorkers(2) // Уменьшает количество воркеров на 2
      ```

- **Закрытие пула:**
    - Метод `CloseAndWait()` останавливает все воркеры и ждет завершения их работы.

---

## Зачем реализованы оба подхода?

Я реализовала пул воркеров двумя способами, чтобы сравнить их производительность и понять, какой подход лучше подходит для разных сценариев использования.

### **Почему сравниваются каналы и `sync.Cond`?**
- Каналы — это высокоуровневый механизм Go, который удобен для передачи данных между горутинами.
- `sync.Cond` — это низкоуровневый механизм, который предоставляет больше контроля над синхронизацией.

---

## Как использовать проект

### Пример использования

####  ChanWorkerPool
```go
package main

import (
	"fmt"
	"sync"

	"github.com/danilovaalina/workerpool"
)

func main() {
	wp := workerpool.NewChanWorkerPool(workerpool.WithJobLimit(10))
	wp.IncWorkers(2)
	defer wp.CloseAndWait()

	var wg sync.WaitGroup

	wg.Add(100)
	for i := range 100 {
		go func() {
			err := wp.Do(func() {
				defer wg.Done()
				fmt.Printf("Processing job %d\n", i)
			})
			if err != nil {
				fmt.Println("Failed to add job:", err)
			}
		}()
	}

	wg.Wait()
}
```

#### CondWorkerPool
```go
package main

import (
	"fmt"
	"sync"

	"github.com/danilovaalina/workerpool"
)

func main() {
	wp := workerpool.NewCondWorkerPool(workerpool.WithBatchSize(10))
	wp.IncWorkers(2)
	defer wp.CloseAndWait()

	var wg sync.WaitGroup

	wg.Add(100)
	for i := range 100 {
		go func(i int) {
			wp.Do(func() {
				defer wg.Done()
				fmt.Printf("Processing job %d\n", i)
			})
		}(i)
	}

	wg.Wait()
}
```

---

## Результаты тестирования

### 1. **Сравнение производительности:**

#### **ChanWorkerPool**
- **Один воркер:**
    - Среднее время выполнения: ~1694 ns/op
- **Несколько воркеров:**
    - Среднее время выполнения: ~1132 ns/op

####  **CondWorkerPool**
- **Один воркер:**
    - Без batch processing: ~228.7 ns/op.
    - С batch processing (`batchSize = 4`): ~221.2 ns/op
- **Несколько воркеров:**
    - Без batch processing: ~289.3 ns/op
    - С batch processing (`batchSize = 4`): ~232.3 ns/op


### 2. **Выводы:**

1. **`sync.Cond` значительно быстрее каналов:**
    - Реализация через `sync.Cond` показывает в среднем **в 5–7 раз лучшую производительность**, чем через каналы.
    - Причина: `sync.Cond` имеет меньше накладных расходов на синхронизацию и управление очередью задач.

2. **Batch processing ускоряет `sync.Cond`:**
    - При использовании `batchSize = 4` время выполнения снижается для одного воркера и еще больше снижается для нескольких воркеров.
    - Причина: Минимизация накладных расходов на взаимодействие с очередью и синхронизацию.

