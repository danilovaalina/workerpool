# Worker Pool

## Описание проекта

Проект включает две реализации пула воркеров:
1. **Через каналы (`ChanWorkerPool`)**.
2. **Через `sync.Cond` (`CondWorkerPool`)**.

Каждая реализация предоставляет настройки для оптимизации производительности, такие как установка размера буфера для очереди задач (jobs) или выполнение задач пакетами (batch processing).

---

### 1. **Настройки ChanWorkerPool**
- **Установка размера буфера для канала задач:**
    - Используйте опцию `WithJobLimit(limit int)` для создания буферизованного канала:
      ```go
      wp := workerpool.NewChanWorkerPool(workerpool.WithJobLimit(100)) // Создает канал с буфером на 100 задач
      ```
    - **Зачем это нужно?**
        - Буферизация канала снижает частоту блокировок при добавлении задач, что особенно полезно при работе с большим количеством задач.

- **Увеличение и уменьшение количества воркеров:**
    - Вы можете динамически изменять количество активных воркеров:
      ```go
      wp.IncWorkers(4) // Увеличивает количество воркеров до 4
      wp.DecWorkers(2) // Уменьшает количество воркеров на 2
      ```

- **Закрытие пула:**
    - Метод `CloseAndWait()` останавливает все воркеры и освобождает ресурсы.

---

### 2. **Настройки CondWorkerPool**
- **Выполнение задач пакетами (batch processing):**
    - Используйте опцию `WithBatchSize(size int)` для выполнения задач кусками:
      ```go
      wp := workerpool.NewCondWorkerPool(workerpool.WithBatchSize(5)) // Воркер берет по 5 задач за раз
      ```
    - **Зачем это нужно?**
        - Batch processing минимизирует накладные расходы на управление очередью и синхронизацию, что улучшает производительность, особенно при работе с I/O-bound задачами.

- **Увеличение и уменьшение количества воркеров:**
    - Аналогично `ChanWorkerPool`, вы можете динамически изменять количество воркеров:
      ```go
      wp.IncWorkers(4) // Увеличивает количество воркеров до 4
      wp.DecWorkers(2) // Уменьшает количество воркеров на 2
      ```

- **Закрытие пула:**
    - Метод `CloseAndWait()` останавливает все воркеры и ждет завершения их работы.

---

## Зачем реализованы оба подхода?

Я реализовала пул воркеров двумя способами, чтобы сравнить их производительность и понять, какой подход лучше подходит для разных сценариев использования.

### **Почему сравниваются каналы и `sync.Cond`?**
- Каналы — это высокоуровневый механизм Go, который удобен для передачи данных между горутинами.
- `sync.Cond` — это низкоуровневый механизм, который предоставляет больше контроля над синхронизацией.

---

## Как использовать проект

### Пример использования

####  ChanWorkerPool
```go
package main

import (
	"fmt"
	"sync"

	"github.com/danilovaalina/workerpool"
)

func main() {
	wp := workerpool.NewChanWorkerPool(workerpool.WithJobLimit(10))
	wp.IncWorkers(2)
	defer wp.CloseAndWait()

	var wg sync.WaitGroup

	wg.Add(100)
	for i := range 100 {
		go func() {
			err := wp.Do(func() {
				defer wg.Done()
				fmt.Printf("Processing job %d\n", i)
			})
			if err != nil {
				fmt.Println("Failed to add job:", err)
			}
		}()
	}

	wg.Wait()
}
```

#### CondWorkerPool
```go
package main

import (
	"fmt"
	"sync"

	"github.com/danilovaalina/workerpool"
)

func main() {
	wp := workerpool.NewCondWorkerPool(workerpool.WithBatchSize(10))
	wp.IncWorkers(2)
	defer wp.CloseAndWait()

	var wg sync.WaitGroup

	wg.Add(100)
	for i := range 100 {
		go func(i int) {
			err := wp.Do(func() {
				defer wg.Done()
				fmt.Printf("Processing job %d\n", i)
			})
			if err != nil {
				fmt.Println("Failed to add job:", err)
			}
		}(i)
	}

	wg.Wait()
}
```

---

## Результаты тестирования

### 1. **Сравнение производительности:**

#### **ChanWorkerPool**

- **Один воркер:**
    - С `select case`:
      - Без ограничения буфера (`JobLimit=0`): ~1120 ns/op.
      - С большим буфером (`JobLimit=100000`): ~1261 ns/op.
    - Без `select case`:
        - Без ограничения буфера (`JobLimit=100`): ~624 ns/op.
        - С большим буфером (`JobLimit=100000`): ~170 ns/op.
- **Несколько воркеров:**
    - С `select case`:
      - Без ограничения буфера (`JobLimit=100`): ~1130 ns/op.
      - С большим буфером (`JobLimit=100000`): ~495 ns/op.
    - Без `select case`:
      - Без ограничения буфера (`JobLimit=100`): ~385 ns/op.
      - С большим буфером (`JobLimit=100000`): ~367 ns/op.

####  **CondWorkerPool**
- **Один воркер:**
    - Без batch processing: ~239 ns/op.
    - С batch processing (`batchSize = 10`): ~217 ns/op
- **Несколько воркеров:**
    - Без batch processing: ~274 ns/op
    - С batch processing (`batchSize = 10`): ~223 ns/op

> Примечание: Удаление проверки закрытия пула (`select case`) значительно улучшило производительность `ChanWorkerPool`. Особенно при одном воркере и большом буфере. Однако это делает пул менее безопасным, так как задачи могут быть добавлены даже после его закрытия.

### 2. **Выводы:**

1. **`sync.Cond` значительно быстрее каналов:**
    - Реализация через `sync.Cond` показывает в среднем **в 2–3 раза лучшую производительность**, чем через каналы.
    - Причина: `sync.Cond` имеет меньше накладных расходов на синхронизацию и управление очередью задач.

2. **Размер буфера канала влияет на производительность `ChanWorkerPool`:**
    - При маленьком буфере (`JobLimit=100`) производительность ниже из-за частых блокировок при отправке задач.
    - При большом буфере (`JobLimit=100000`) производительность улучшается, даже становится выше при одном воркере, чем у `CondWorkerPool`.

3. **Отказ от `select case` повышает скорость работы `ChanWorkerPool`:**
    - Это снижает накладные расходы на проверку состояния пула, но делает реализацию менее безопасной.
    - Задачи могут быть добавлены даже после закрытия пула, что может привести к неопределенному поведению.

4. **Batch processing ускоряет `sync.Cond`:**
    - При использовании `batchSize = 10` время выполнения снижается как для одного, так и для нескольких воркеров.
    - Причина: Минимизация накладных расходов на взаимодействие с очередью и синхронизацию.

5. **Решение через `sync.Cond` выглядит более универсально:**
    - `CondWorkerPool` работает стабильно с разными настройками и не требует ручной настройки буфера или других параметров.
    - Производительность остается высокой независимо от количества воркеров или объема задач.


